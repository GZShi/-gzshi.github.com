<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[石头的博客]]></title>
  <link href="http://lovep.me/atom.xml" rel="self"/>
  <link href="http://lovep.me/"/>
  <updated>2013-04-30T16:12:09+08:00</updated>
  <id>http://lovep.me/</id>
  <author>
    <name><![CDATA[GZShi(s@lovep.me)]]></name>
    <email><![CDATA[s@lovep.me]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用双眼识别条形码]]></title>
    <link href="http://lovep.me/blog/2013/04/30/bar-code/"/>
    <updated>2013-04-30T15:22:00+08:00</updated>
    <id>http://lovep.me/blog/2013/04/30/bar-code</id>
    <content type="html"><![CDATA[<h3>条形码</h3>

<p>条形码应用的广泛程度不用我去赘述，随便拿起身边的饮料瓶或一本书，很容易便会发现印在其包装或封底的条形码。条形码被誉为印在纸上的机器语言，因为其记录的信息非常方便用机器读取。<br/>
条形码的格式丰富多样，每一种格式都有特定的编码规则，其中EAN-13格式最为常见。EAN是“European Article Number”的简写，13代表代码长度。最初EAN只是欧洲范围内使用，但是现在已经成了全球范围内产品交易的上平代码。你看到的书、喝的果汁、吃的饼干这些商品包装上的条形码都是采用这种格式。</p>

<h4>基本结构</h4>

<p>EAN-13的每一位数字都有特定含义，但是我不打算去细究这些东西，如果有兴趣请移步维基百科上<a href="http://zh.wikipedia.org/wiki/EAN">关于EAN的介绍</a>。现在只需要把EAN-13分为两个部分：前12位和最后1位。前12位称为数据位，最后一位称为校验位。</p>

<!-- more -->


<p></p>

<h4>更细基本单位</h4>

<p>条形码的可读范围从最左边的第一条黑条开始，一直到最右边的黑条。仔细看你会发现最左和最右的黑条是最细的，再仔细看你又会发现中间的那些宽一点的黑条只会是最左边黑条的2倍、3倍或4倍宽。如果把最左黑条旁边的白色空隙看做白条，你会发现这一条白条和最细的黑条一样宽，而且是所有白条中最细的，中间的宽一点的白条都是这条白条的2倍、3倍或4倍。如果你发现某个条形码最宽的黑条/白条比最窄的黑条/白条宽4倍以上，那么这个条形码一定是错误的或者被篡改了。<br/>
且将最窄的黑条记为<code>1</code>，最窄的白条记为<code>0</code>，那么如下图所示的条形码就可以记为<code>1010011101</code><br/>
<img src="http://lovep.me/images/blog/2013043001.png" alt="barcode" /><br/>
如果你的眼睛足够犀利，那么任何黑白交错的条形码都能被你的双眼转换为类似上面的<code>01</code>串，这正是识别条形码的基础，有了这些<code>01</code>串，就可已进入下一步识别步骤了，不过在进入下一步之前，请再仔细观察一下条形码。<br/>
条形码最左边的3条（101）、最右边的三条、和中间的5条（01010）都会比其它的条形要长一点，这三个区域叫做这个二维码的护线，二维码的数据位或校验位的信息并不会记录在这3个区域当中，他们存在的作用仅仅是告诉识别机器它们是这段条形码的开始、中间和结束部分，并且他们的黑条和白条是最窄的，是其它条形宽度的参考。</p>

<h4>数据组成</h4>

<p>擦亮大家的双眼，一起来把下面的条形码翻译成<code>01</code>串，其中护线和数据位可以稍微留一点空白便于区分<br/>
<img src="http://lovep.me/images/blog/2013043002.png" alt="barcode" /><br/>
我的得到的结果是：<br/>
<code>101</code><br/>
<code>011101100010010010001001100100110110011001</code><br/>
<code>01010</code><br/>
<code>110011010010001100110110011010010001011100</code><br/>
<code>101</code><br/>
把上面的护线部分忽略掉，把剩下的串按每7位组成一个部分，我们将得到下面这样的更细的片段：<br/>
左边 <code>0111011</code> <code>0001001</code> <code>0010001</code> <code>0011001</code> <code>0011011</code> <code>0011001</code><br/>
右边 <code>1100110</code> <code>1001000</code> <code>1100110</code> <code>1100110</code> <code>1001000</code> <code>1011100</code><br/>
上面的每一个部分都只表示一个数字。按照这个规则上面刚好只有12个数，和之前所说的13个数字有偏差。那另外一个数字丢哪里了呢？请继续看下去。<br/>
看看上面的数字，你会发现一个规律，左边的每一个数字都是以<code>0</code>开头、以<code>1</code>结尾，右边的数字则刚好相反。这正是条形码的查错方式之一，如果发现读取的条形码不符合上面规则，那么这个条形码是有错误的。<br/>
接下来将上面的各个待解读的数字分为两类：有奇数个<code>1</code>的奇类、有偶数<code>1</code>的偶类。例如，<code>0111011</code>有奇数个<code>1</code>，<code>0001001</code>有偶数个<code>1</code>。根据这个分类你会发现，左边的部分有一些是奇类有一些是偶类，右边的全是偶类。如果你在读取过程中发现右边的部分中存在奇类，那么这个条形码一定是错误的。<br/>
下面是这些<code>01</code>串和数字的对应规则：</p>

<blockquote><p>奇类<br/>
0001101 -> 0　　0110001 -> 5<br/>
0011001 -> 1　　0101111 -> 6<br/>
0010011 -> 2　　0111011 -> 7<br/>
0111101 -> 3　　0110111 -> 8<br/>
0100011 -> 4　　0001011 -> 9</p>

<p>偶类<br/>
1110010 -> 0　　1001110 -> 5<br/>
1100110 -> 1　　1010000 -> 6<br/>
1101100 -> 2　　1000100 -> 7<br/>
1000010 -> 3　　1001000 -> 8<br/>
1011100 -> 4　　1110100 -> 9</p></blockquote>

<p>现在可以开始读数字了，左边第一个是<code>0111011</code>，属于奇类，根据对应规则得到的数字是7。左边第二个是<code>0001001</code>，属于偶类，可是找遍所有的偶类规则都不能匹配。还是条形码有问题？还是我们的01串读错了？其实左边的偶类在读取的时候是要逆向读的，也就是说，刚刚的<code>0001001</code>先要转换成<code>1001000</code>然后再去偶类规则里去找对应的数字。现在我们很容易就找到第二个对应数字是8。依次类推，我们把剩下的数字都能读出来，最后的结果应该是<code>787121</code>和<code>181184</code>。<br/>
之前悬着的问题是时候面对了——说好的13个数字呢？！其实这个被遗忘的数字就藏在<code>01</code>串当中，如果把<code>01</code>串左边的部分的奇类看为<code>1</code>，偶类看为<code>0</code>，那么左边会得到一个新的6位串<code>100101</code>，这个串的读取规则如下：</p>

<blockquote><p>111111 -> 0　　100110 -> 5<br/>
110100 -> 1　　100011 -> 6<br/>
110010 -> 2　　101010 -> 7<br/>
110001 -> 3　　101001 -> 8<br/>
101100 -> 4　　100101 -> 9</p></blockquote>

<p>根据规则，得到的数字是9。把这个数字和之前读取的数字连起来就是<code>978712118184</code>，掏出手机扫描一下即可验证其是正确的。</p>

<h4>校验规则</h4>

<p>条形码有一个非常重要的特点就是防止篡改，这在实际使用中是非常重要的。根据EAN-13规则，<code>978712118184</code>的最后一个数字<code>4</code>是校验位，用于检验前面的数字是否被修改过，具体的检验步骤如下：<br/>
1. 取数据位中的奇数位求和得到S1<br/>
2. 取数据位中的偶数位求和得到S2<br/>
3. S3 = S1 + S2 * 3<br/>
4. M = S3 % 10（取S3的个位数）<br/>
5. C = 10 - M</p>

<p>C就是最后的校验结果，这个结果和第13位做比较，如果不同就代表数据有问题。<br/>
结合上面的奇类偶类读取规则不难发现，简单的涂改一定会导致条形码出错的。不过这也是条形码的一个短处所在，如果不经意之间损坏了条形码的结构，哪怕只有一条，都会导致其中的信息完全失效，也就是说条形码没有容错功能。那么有没有既有防篡改又能纠错的条形码呢？答案是肯定的，这个“条形码”叫做“二维码”！</p>

<h3>生成条形码</h3>

<p>知道了EAN-13的规则，就可以动手写一个生成条形码的应用了。输入一个12位（不含校验的情况）或13位数字，就能生成相应的条形码：</p>

<div style='background:rgba(133, 133, 133, 0.1); margin:0 auto'>
    <span>输入12位或13位数字：</span>
    <input type='text' value='978712118184' id='in'>
    <button onclick='create()'>Create</button><br>
    <canvas id='c' width='400px' height='300px'></canvas>
    <script src="https://gist.github.com/GZShi/5487022/raw/56993bda7dce942fbcf423d4e507b82b7b9dff20/BarCode.js"></script>
    <script type="text/javascript">create();</script>
</div>


<p>下面是JavaScript代码链接:<br/>
<a href="https://gist.github.com/GZShi/5487022">https://gist.github.com/GZShi/5487022</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贪吃蛇也需要思考人生]]></title>
    <link href="http://lovep.me/blog/2013/04/27/snake-ai/"/>
    <updated>2013-04-27T23:09:00+08:00</updated>
    <id>http://lovep.me/blog/2013/04/27/snake-ai</id>
    <content type="html"><![CDATA[<h3>我的贪吃蛇历史</h3>

<p>在九宫格手机风靡的时代，贪吃蛇可以说是一部手机的标配，至少诺基亚的手机肯定会有。什么时候第一次接触贪吃蛇我已经不记得了，但是关于贪吃蛇我倒是有几段比较清晰的记忆。</p>

<h4>黑白屏经典贪吃蛇</h4>

<p>高一的时候，坐在我后面的<a href="http://weibo.com/greenarlene">同学</a>有一部挂着草莓挂坠的小灵通，刚好里面有贪吃蛇游戏，是最经典最简单的那种，有墙壁，没有障碍，蛇的身体是一个个黑色小方块，速度不会改变，吃一粒食物，长一节身体。<br/>
这种小游戏的特点就是上手容易，高分很难，也许这正是贪吃蛇能经久不衰的原因吧。每次都希望以最短的时间去冲击排行榜上的最高分，但往往都会因为一个非常小的失误含恨撞墙或咬蛇自尽。</p>

<!-- more -->


<p>
这种经典模式的要诀是开始的时候尽量走最短的路径去吃到食物，到了比较长的时候就只能迂回前进，把身体尽可能的缩成一团，不要留缝隙。如果按照这种策略去玩还不能吃尽最后一个食物，唯一的原因就是手残，需要转弯的时候按慢了或者按错键。显然，我一直都没有吃尽食物（原因你懂的），所以入迷了很长一段时间。<br/>
说到黑白贪吃蛇，就不得不提诺基亚，就算是屏幕很小的机型，贪吃蛇也做的非常有特色，蛇的细节刻画得很好，玩法也多种多样。具体有多少种模式已经不太记得，但是里面的成就系统还是非常吸引人的。</p>

<h4>3D贪吃蛇</h4>

<p>如果你用过塞班系统，一定会听说过诺基亚的那款3D贪吃蛇，保留了诺基亚贪吃蛇制作精良的一贯特色。这款贪吃蛇玩法和经典贪吃蛇截然不同，控制蛇的方向不再是使用上、下、左、右这样的绝对方向去控制，而是只能使用左转、右转、左转两次、右转两次这样的相对方向去控制蛇的前进方向。整个地图也不像经典贪吃蛇那样全部以一张平面图的方式将所有元素铺满整个屏幕，3D贪吃蛇屏幕里面能看到的只有位于蛇前进方向的一个扇形视野区域，或者蛇头附近的一小块区域，在前进过程中可以切换视角看到左方或右方的视野。<br/>
这款游戏有30多个关卡，每一个关卡的地图都是不一样的，地图上面有障碍，碰到障碍身体会变短，当不能再变短时就会死亡。地图上的食物不止一个，存在的地点也不是随机的，如果能连续吃到一整段食物则会有的分加倍的效果。<br/>
最精彩的地方是整个地图是一个3D空间，在一些关卡里，地图没有边界，类似于现实中的地球，往一个地方一直走会回到原点。有些关卡有边界，但是你冲向边界的那一刻，蛇不会死亡，而是进入了一个全新的地图，另一个次元。<br/>
这款游戏我高三的时候才接触的，在紧张学习之余召唤一条贪吃蛇，在另外一个世界驰骋，也算是一种解压的方式。谢谢<a href="about:blank">同学</a>提供设备。</p>

<h4>码农的贪吃蛇</h4>

<p>去年冬天在公司实习，无聊的时候瞄了一眼JavaScript，发现里面的数组有一个shift()方法，一下子就觉得这个语言好有趣，于是想用这个语言写点什么，顺便用上这个shift()操作。正巧当时在对canvas很感兴趣，于是便萌生了写一个HTML5的贪吃蛇的想法。这算是我开始JavaScript学习的时候吧。我写了好几个版本，在写两条贪吃蛇对战的版本时萌生了写贪吃蛇AI的想法，但是这仅仅停留在想一下的阶段，没有去细想。后来公司的工作越来越多，慢慢的就将贪吃蛇项目搁浅了。<br/>
前一阵子微博上有一张非常火的GIF图，里面有一条贪吃蛇最终把整个屏幕吃满了。说实话，作为一名贪吃蛇骨灰级玩家我被彻底震惊了。后来在和<a href="http://dingstyle.me">丁式呆</a>在等待<a href="http://mutong37.com">木橦</a>去骑自行车玩的时候提到了这条风骚的蛇，于是共同决定实现一个贪吃蛇AI。开始的时候觉得这个AI应该很好实现，做一个广度优先搜索就行了，后来我们才发现，贪吃蛇的人蛇生远不止这么简单……</p>

<h3>贪吃蛇的人生哲学</h3>

<p><a href="http://dingstyle.me">丁式呆</a>的贪吃蛇AI<a href="https://github.com/metaphysiks/snake-ai">在此</a>，可以先感受一下他的<a href="http://dingstyle.me/blog/2013/04/26/snake-ai/">哲学</a>。</p>

<h4>论吃和活的重要性</h4>

<p>首先贪吃蛇要明白一个道理，只有活下去，才能吃到更多的食物。在吃一个食物的时候就应该仔细研究一下这粒食物是不是“敌人”设下的陷阱，也许贸然吃下这粒食物就会走入一条不归路，最后只能咬蛇自尽。对于这样的食物一定小心，先和食物慢慢周璇，调整一下自己的姿势，在形势利好的时候在以迅雷不及掩耳之势上前取之。</p>

<h4>做事之前先找好退路</h4>

<p>在贪吃蛇的世界里，只有自己的尾巴会不断腾出新的空间，因此，贪吃蛇的头部尽量和蛇的尾巴保留在一个连通的区间里面。这是一条不可逾越准则，这比吃食物更重要，切记。如果你是一条高瞻远瞩的蛇，能预测到即使与蛇尾暂时失去联系，在不远的将来仍然能够重新会和，那另当别论。</p>

<h4>穷途末路时放慢脚步，思考人生</h4>

<p>当贪吃蛇发现心爱的食物和自己不在一个次元，没有一条有效的路径到达时，就应该把一贯的横冲直撞的风格改一下，留意一下身边的景色，把身边的每一个空白都当做食物来看待，不要在自己走过的地方附近留下空白。同时不断关注变化的世界，根据食物守恒定律，食物总会到来的。</p>

<h4>不要贪图眼前的利益</h4>

<p>你有把握在10步以内吃到食物？吃完食物还能保证和蛇尾在一个区间？如果你吃食物之前仔细思考了上面两个问题，那么你已经是一条优秀的蛇了，你肯定能够在贪吃蛇的世界闯出一片天地，能达到普通贪吃蛇所不能达到的境界。但是你有没有思考过你快速吃到了当前的食物，下一个食物你将会付出非常大的代价？这个情况在你自身已经很长的时候尤为明显，往往为了吃一个食物而将整个世界都跑一遍。其实，当你身体已经很长的时候，面对食物不要再像年轻人那样急功近利，老练地迂回一下，往往能保证下一个食物也能很快吃到。这个故事告诉我们贪心算法的解决方法往往不是最优的解决方法，局部次优解往往能获得更好的全局解决方法。</p>

<h4>少年的时习惯很重要</h4>

<p>作为一条优秀的贪吃蛇，你能吃到很多很多的食物，但慢慢的你会发现，食物越来越难吃到，吃一个食物往往要绕好久好久；食物的位子也越来越刁钻，好像是故意长在你不容易够到的地方一样。其实追根揭底，这都是你年轻时候的错误。人生亦如此，年轻的时候做事吃东西往往顾目的，而不顾过程，做事的时候能够完成任务，但是对一些相关的知识不去仔细深究。年少的时候觉得没什么关系，但是你会发现这些时候时留下的一些空白、知识盲点往往会在你中年的时候暴露出缺点来。升职越来越难，做事开始力不从心，你是否有反思过年轻的过错呢。</p>

<h4>人生路长不要轻言放弃</h4>

<p>我的这个贪吃蛇AI是由<a href="http://dingstyle.me">丁式呆</a>的AI改写的，增加了一些我对贪吃蛇哲学的认识，目前程度只能算是普通，比原来AI更差劲一点。算是优秀的贪吃蛇，但是离非常优秀还很远，至于高瞻远瞩更是遥不可及。但是我会不断改进它，朝那个遥不可及的目标前进。</p>

<div>
    <canvas id='c' width='100px' height='100px'></canvas>
    <script type="text/javascript" src='http://code.jquery.com/jquery-1.9.1.min.js'></script>
    <script type="text/javascript">
var FPS = 10;                   
var SNAKE_COLOR = {r:90, g:196, b:255};
var FOOD_COLOR = 'black';
var WIDTH = 15;                 // 格子横向数目
var HEIGHT = 15;                // 格子纵向数目
var C_WIDTH = 100;              // 画布宽度像素
var C_HEIGHT= 100;              // 画布高度像素
var P_WIDTH = C_HEIGHT / WIDTH; // 一节身体宽度
var P_HEIGHT= C_HEIGHT / WIDTH; // 一节身体高度
var WEST = 'w';
var EAST = 'e';
var NORTH = 'n';
var SOUTH = 's';
var LEFT = 'l';
var RIGHT = 'r';
var FRONT = 'f';
var BACK = 'b';

function rgba(r, g, b, a) {
    return "rgba(" + r + ", " + g + ", " + b + ", " + (a != null ? a : 1) + ")";
}

function randInt(min, max) {
    return Math.floor(Math.random()*(max-min) + min);
}

function borderCell(dr, cell) {
    switch(dr) {
        case WEST:
            return new Point(cell.x-1, cell.y);
        case EAST:
            return new Point(cell.x+1, cell.y);
        case NORTH:
            return new Point(cell.x, cell.y-1);
        case SOUTH:
            return new Point(cell.x, cell.y+1);
        default:
            return new Point(cell.x, cell.y);
    }
}

function isCellFree(cell, snake) {
    if(cell.x < 0 || cell.y < 0 || cell.x >= WIDTH || cell.y >= HEIGHT)
        return false;
    for(var i = 0, len = snake.body.length-1; i < len; ++i) {
        if(snake.body[i].equals(cell))
            return false;
    }
    return true;
}

function isOpposite(dr1, dr2) {
    switch(dr1) {
        case WEST:
            if(dr2 == EAST)
                return true;
            break;
        case EAST:
            if(dr2 == WEST) 
                return true;
            break;
        case NORTH:
            if(dr2 == SOUTH)    
                return true;
            break;
        case SOUTH:
            if(dr2 == NORTH)    
                return true;
            break;
        default:
            break;
    }
    return false;
}

function turn(d, t) {
    switch(d) {
        case WEST:
            if(t == RIGHT)
                return NORTH;
            else if(t == LEFT)
                return SOUTH;
            else if(t == BACK)
                return EAST;
            break;
        case EAST:
            if(t == RIGHT)
                return SOUTH;
            else if(t == LEFT)
                return NORTH;
            else if(t == BACK)
                return WEST;
        break;
        case NORTH: 
            if(t == LEFT)
                return WEST;
            else if(t == RIGHT)
                return EAST;
            else if(t == BACK)
                return SOUTH;
        break;
        case SOUTH:
            if(t == LEFT)
                return EAST;
            else if(t == RIGHT)
                return WEST;
            else if(t == BACK)
                return NORTH;
        break;
        default:
        break;
    }
    return d;
}

var Point = (function(){
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    Point.prototype.add = function(other) {
        return new Point(this.x+other.x, this.y+other.y);
    }

    Point.prototype.equals = function(other) {
        return this.x == other.x && this.y == other.y;
    }

    Point.prototype.toString = function() {
        return '('+this.x+','+this.y+')';
    }

    return Point;
})();

var Snake = (function(){
    function Snake(head, direction) {
        this.body = [head];
        this.direction = direction!=null ? direction : EAST;
    }

    Snake.prototype.head = function() {
        return this.body[0];
    }

    Snake.prototype.tail = function() {
        return this.body[this.body.length - 1];
    }

    Snake.prototype.fork = function() {
        var snake = new Snake(new Point(0, 0));
        snake.body = this.body.slice(0);
        snake.direction = this.body.direction;
        return snake;
    }

    Snake.prototype.advance = function(cmd) {
        if(cmd == LEFT || cmd == RIGHT || cmd == FRONT || cmd == BACK) {
            this.direction = turn(this.direction, cmd);
        }
        else if(!isOpposite(cmd, this.direction)) {
            this.direction = cmd;
        }
        this.body.unshift(borderCell(this.direction, this.body[0]));
    }

    Snake.prototype.move =function(cmd) {
        this.advance(cmd);
        this.moveTail();
    }

    Snake.prototype.moveTail = function() {
        this.body.pop();
    }

    Snake.prototype.bodyHit = function() {
        // 忽略头部
        var toCheck = this.body.slice(1, this.body.length);
        for(var i = 0, len = toCheck.length; i < len; ++i) {
            if(this.body[0].equals(toCheck[i]))
                return true;
        }
        return false;
    }

    Snake.prototype.wallHit = function() {
        var x = this.body[0].x;
        var y = this.body[0].y;
        return (x < 0 || y < 0 || x > WIDTH || y > HEIGHT);
    }

    Snake.prototype.draw = function(ctx) {
        // draw head
        ctx.fillStyle = rgba(90, 196, 255, 0.8);

    }

    return Snake;
})();

var Game = (function(){
    function Game(ctx) {
        this.ctx = ctx;
        this.fps = FPS;
        this.food = new Point(5, 5);
        this.score = 1;
        this.snake = new Snake(new Point(1, 1));
        this.commands = [];
    }

    Game.prototype.draw = function() {
        this.ctx.clearRect(0, 0, C_WIDTH, C_HEIGHT);
        // draw food
        this.ctx.fillStyle = FOOD_COLOR;
        this.ctx.fillRect(this.food.x*P_WIDTH, this.food.y*P_HEIGHT, P_WIDTH, P_HEIGHT);
        // draw snake
        for(var i = 0, len = this.snake.body.length; i < len; ++i){
            this.ctx.fillStyle = rgba(SNAKE_COLOR.r, SNAKE_COLOR.g, SNAKE_COLOR.b, 1-0.7*(i/len));
            this.ctx.fillRect(
                this.snake.body[i].x * P_WIDTH,
                this.snake.body[i].y * P_HEIGHT,
                P_WIDTH, P_HEIGHT);
        }
    }

    Game.prototype.placeFood = function() {
        if(this.snake.body.length >= WIDTH*HEIGHT - 1)
            return false;
        var nfood;
        while(true) {
            nfood = new Point(randInt(0,WIDTH), randInt(0, HEIGHT));
            if(this.snake.body.every(function(s){
                return !s.equals(nfood);
            })) {
                this.food = nfood;
                return true;
            }
        }
    }

    Game.prototype.onTick = function() {
        this.draw();
        if(this.commands.length == 0) {
            // call AI function
            this.commands = Array.prototype.slice.apply(getCmd(this.snake, this.food));
        }
        this.snake.advance(this.commands.shift());
        if(this.snake.head().equals(this.food)) {
            if(false == this.placeFood()) {
                this.stop();
            }
            this.score += 1;
        } else {
            this.snake.moveTail();
        }
        if(this.snake.wallHit() || this.snake.bodyHit()) {
            this.stop();
        }
    }

    Game.prototype.play = function() {
        var _this = this;
        this.ticker = setInterval(function(){
            return _this.onTick();
        }, 1000/this.fps);
    }

    Game.prototype.stop = function() {
        clearInterval(this.ticker);
    }

    return Game;
})();

// AI code

var pathRecord = (function(){
    function pathRecord(node, direction, parentRecord) {
        this.cell = node;
        this.direction = direction ? direction : '';
        this.parent = parentRecord;
    }

    pathRecord.prototype.traceCmd = function(){
        if(this.parent) {
            return this.parent.traceCmd() + this.direction;
        } else {
            return '' + this.direction;
        }
    };

    return pathRecord;
})();

function findPathToCell(snake, food) {
    var head = snake.head();
    var queue = [new pathRecord(head)];
    var mark = (function(){
        var array = [];
        for(var i = 0; i < HEIGHT; ++i) {
            array[i] = [];
            for(var j = 0; j < WIDTH; ++j) {
                array[i][j] = false;
            }
        }
        return array;
    })();
    var node, cell, dirs, fd;
    while(queue.length > 0) {
        node = queue.shift();
        if(mark[node.cell.y][node.cell.x] == true)  continue;
        if(food.equals(node.cell)) {
            return node.traceCmd();
        }
        mark[node.cell.y][node.cell.x] = true;
        fd = node.direction == '' ? snake.direction : node.direction;
        dirs = [fd, turn(fd, LEFT), turn(fd, RIGHT), turn(fd, BACK)];
        for(var i = 0; i < 4; ++i) {
            cell = borderCell(dirs[i], node.cell);
            if(isCellFree(cell, snake)) {
                queue.push(new pathRecord(cell, dirs[i], node));
            }
        }
    }
    return false;
}

function getLongestDistance(snake, cell1, cell2) {
    var queue = [];
    var mark = (function(){
        var array = [];
        for(var i = 0; i < HEIGHT; ++i) {
            array[i] = [];
            for(var j = 0; j < WIDTH; ++j) {
                array[i][j] = -1;
            }
        }
        for(var i in snake.body) {
            array[snake.body[i].y][snake.body[i].x] = 0;
        }
        array[cell1.y][cell1.x] = array[cell2.y][cell2.x] = -1;
        return array;
    })();
    if(isCellFree(cell1, snake)) {
        queue.push(cell1);
        mark[cell1.y][cell1.x] = 0;
    }
    var node;
    while(queue.length > 0) {
        node = queue.pop();
        if(cell2.equals(node)) {
            var dx = Math.abs(cell2.x - cell1.x);
            var dy = Math.abs(cell2.y - cell1.y);
            return dx > dy ? cell2.y : cell2.x
        }
        var dirs = [NORTH, WEST, SOUTH, EAST];
        for(var i = 0; i < 4; ++i) {
            var cell = borderCell(dirs[i], node);
            if(isCellFree(cell, snake) && mark[cell.y][cell.x] == -1) {
                queue.push(cell);
                mark[cell.y][cell.x] = mark[node.y][node.x] + 1;
                cell = borderCell(dirs[(i+1)%4], cell);
                if(isCellFree(cell, snake) && mark[cell.y][cell.x] == -1) {
                    queue.push(cell);
                    mark[cell.y][cell.x] = mark[node.y][node.x] + 1;
                }
            }
        }
    }
    return -1;  // can't arrival
}

function followSnakeTail(snake) {
    var head = snake.head();
    var distance = (function(){
        var array = [];
        for(var i = 0; i < HEIGHT; ++i) {
            array[i] = [];
            for(var j = 0; j < WIDTH; ++j) {
                array[i][j] = 0;
            }
        }
        return array;
    })();

    var fork;
    var dir = snake.direction;
    var dirs = [dir, turn(dir, LEFT), turn(dir, RIGHT)];
    var distance = [];
    for(var i = 0; i < 3; ++i) {
        var newhead = borderCell(dirs[i], head);
        if(isCellFree(newhead, snake))
            distance[i] = getLongestDistance(snake, snake.tail(), newhead);
        else 
            distance[i] = -1;
    }
    var max =   distance[0] > distance[1] ?
                (distance[0] > distance[2] ? 0 : 2) :
                (distance[1] > distance[2] ? 1 : 2);
    return dirs[max];
}

function getCmd(snake, food) {
    var path = findPathToCell(snake, food);
    if(false == path || path.length >= (WIDTH*HEIGHT-snake.length)*0.3) {
        return followSnakeTail(snake);
    }
    var fork = snake.fork();
    for(var i = 0, len = path.length; i < len-1; ++i) {
        fork.advance(path[i]);
        fork.moveTail();
    }
    fork.advance(path[i]);
    if(false == findPathToCell(fork, fork.tail())) {
        return followSnakeTail(snake);
    }
    return path;
}

// AI END

var context = $('#c')[0].getContext('2d');
var game = new Game(context);
game.play();

    </script>
</div>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[琐碎的事]]></title>
    <link href="http://lovep.me/blog/2012/10/30/broken-pieces/"/>
    <updated>2012-10-30T19:36:00+08:00</updated>
    <id>http://lovep.me/blog/2012/10/30/broken-pieces</id>
    <content type="html"><![CDATA[<p>东三吃吐了，加上要去百味附近取钱，所以晚饭选择在百味。</p>

<p>去百味吃饭，到了食堂才发现饭卡没带。</p>

<p>回寝室拿了饭卡，再次来到百味，刷烧鹅饭的时候发现卡上只有8块钱。</p>

<p>吃晚饭去取钱，到了ATM机前发现银行卡不在钱包里。</p>

<p>回宿舍把所有地方都翻了个遍都没发现银行卡，这已经是近半年来第二次弄丢银行卡啦！</p>

<p>真是二到家了。明天还得去挂失银行卡，好像上次的时候也是星期三来着。</p>

<p>最近做什么事情都静不下心来，没头没尾的，心烦意乱。</p>

<p>昨天发现AVAST突然异常地占资源，怒删之，改用MSE。晚上的时候发现ipv6网站上不去了，希望不是MSE的原因</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0不等于0]]></title>
    <link href="http://lovep.me/blog/2012/10/20/detail-of-c-int-float/"/>
    <updated>2012-10-20T00:43:00+08:00</updated>
    <id>http://lovep.me/blog/2012/10/20/detail-of-c-int-float</id>
    <content type="html"><![CDATA[<p>如果两个浮点数表示0，那么这两个浮点数的大小是否一样呢？也许你会马上想到用下面这个程序来验证你的想法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">float</span> <span class="n">f1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">float</span> <span class="n">f2</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">)</span>
</span><span class='line'>      <span class="n">puts</span><span class="p">(</span><span class="s">&quot;equal!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>毫无疑问，这个程序的显示结果必然是<code>equal!</code>。</p>

<!-- more -->


<p>那么尝试一下运行下面的程序</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x8000ffff</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">float</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">float</span> <span class="o">*</span><span class="n">f2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">f1</span> <span class="o">!=</span> <span class="o">*</span><span class="n">f2</span><span class="p">)</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f != %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">f1</span><span class="p">,</span> <span class="o">*</span><span class="n">f2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行后你会发现显示的结果是<code>-0.000000 != -0.000000</code>，这个结果有点违反直觉，为什么呢？这还得从计算机如何表示浮点数说起。<br/>
c语言是按照<a href="http://zh.wikipedia.org/wiki/IEEE_754"><code>IEEE 754</code></a>的标准表示浮点数的。所有能表示的浮点数可以分为三类：<code>规格化的值</code>、<code>非规格化的值</code>和<code>特殊值</code>。</p>

<p>规格化的值表示阶码不全为1或全为0的数。非规格化的值表示阶码全为0的数，这种数的其中一个用途是提供了0的表示方式，因为在规格化的数中尾数总是包含一个1的，这样不可能表示0，当阶码全为0时无论尾数如何，表示的都是0.0或-0.0。特殊值是阶码全为1的数，表示一个无穷大，根据符号位决定是正无穷或负无穷，这不是一个数。</p>

<p>回到刚才的程序，f1和f2指向的都是一个非规格化的数，因此字面上的值都是0.0，但为什么比较起来会不一样呢？</p>

<p>其实IEEE 754的设计是非常妙的，阶码的值是采用特殊移码表示而且偏置值是-127而不是-128，这样提供了一个从非规格化的值向规格花的值平滑过渡的表示方法。如果把浮点数在内存中的表达方式用整型解释的话，得到的数和浮点表示的时候的大小顺序是一致的，如此的话在比较两个浮点数大小的时候就能直接采用处理整型数的方法去处理浮点数，这样能降低浮点数处理的复杂度。</p>

<p>这样就不难解释为什么上面的程序的结果为什么会如此了。</p>

<h3>参考引用</h3>

<ol>
<li>《深入理解计算机系统》，Randal E. Bryant  David R. O&#8217;Hallaron 著，龚奕利 雷迎春 译。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断闰年]]></title>
    <link href="http://lovep.me/blog/2012/10/09/huawei-code-test/"/>
    <updated>2012-10-09T14:47:00+08:00</updated>
    <id>http://lovep.me/blog/2012/10/09/huawei-code-test</id>
    <content type="html"><![CDATA[<p><a href="http://zh.wikipedia.org/zh/%E9%97%B0%E5%B9%B4">闰年</a>这个概念大概是小学刚学除法的时候接触的吧，记得比较清楚的是“闰年都能被4整除”。大一的时候学C语言的时候又接触到闰年，判断方法说的很清楚</p>

<blockquote><p>“四年一闰，百年不闰，四百年再闰”</p></blockquote>

<p>没有想到的是，在今天早上的华为机试中又遇到了这个闰年！</p>

<p>题目很简单，就是要你判断输入的数是否是闰年，是就输出&#8221;YES&#8221;，不是就输出&#8221;NO&#8221;。</p>

<!--more -->


<p>为了这次上机测试，我特意查了下华为前几年的上机测试题，虽然不是很难，但也不会简单到这个样子，而且以前都不止一道题，码代码的时间也不止30分钟（当然，这个题30分钟的时间显得太充裕了），昨晚还没睡好，看了好多面试题目……看到这个题目我第一想法就是——大坑！</p>

<p>本来想用一个条件语句判断的，但是头脑一热就懒得想这么多了，直接上if-else</p>

<div><script src='https://gist.github.com/3857116.js?file='></script>
<noscript><pre><code>#include &lt;stdio.h&gt;

#define TRUE 1
#define FALSE 0

int judge(int year)
{
    if(year % 4 != 0)
        return FALSE;
    else if(year % 100 == 0)
    {
        if(year % 400 == 0)
            return TRUE;
        else
            return FALSE;
    }
    else 
        return TRUE;
}

int main(void)
{
    int year = 0;
    char *s[2] = {&quot;NO&quot;, &quot;YES&quot;};

    scanf(&quot;%d&quot;, &amp;year);

    printf(&quot;%s\n&quot;, s[judge(year)]);

    return 0;
}
</code></pre></noscript></div>


<p>测试了几个例子，测试正确后便很满足地提交了。但是提交后发现检查结果有5%的测试样例没通过，刚刚还信心满满的我一下子就被打击到了，再三检查了程序的逻辑，实在找不出有什么逻辑方面的错误。</p>

<p>走出软件园，实在是很郁闷，路上一直想着刚刚的程序，一直在想那5%的错误是怎么出现的。突然想到他给的样例是用字符串保存输入的而非整型，莫非测试的时候用了一个非常大的数导致整型溢出出现错误，想到这里我发现我的程序里面却是没有想到这点。回来后我又重新写了一个</p>

<div><script src='https://gist.github.com/3857174.js?file='></script>
<noscript><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_LEN 255
#define TRUE 1
#define FALSE 0

int judge(char *str)
{
    int year = 0;
    if(strlen(str) &gt; 9)  // 超出一个32bit能表示的最大位数
    {
        strcpy(str, str + strlen(str) - 4);
        year = (str[0] - '0')*1000 + (str[1] - '0')*100 + (str[2] - '0')*10 + str[3] - '0';
    }
    else
        year = atoi(str);

    return (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0));
}

int main(void)
{
    char str[MAX_LEN];
    char *s[2] = {&quot;NO&quot;, &quot;YES&quot;};

    fscanf(str, MAX_LEN - 1, stdin);

    printf(&quot;%s\n&quot;, s[judge(str)]);

    return 0;
}
</code></pre></noscript></div>


<p>真是再简单的事情也有意想不到的情况。</p>

<p>PS. 机试的地点真是太难找了，标个记！</p>

<p><iframe src="http://www.dr2ooo.com/tools/maps/maps.php?zoom=12&width=500&height=400&ll=30.475123,114.404669&ctrl=true&cp=true&" width="500" height="400"></iframe></p>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2009级华中科技大学计算机保研C语言上机题目]]></title>
    <link href="http://lovep.me/blog/2012/09/29/hust-graduate-retest/"/>
    <updated>2012-09-29T13:45:00+08:00</updated>
    <id>http://lovep.me/blog/2012/09/29/hust-graduate-retest</id>
    <content type="html"><![CDATA[<p>在某种基友光环的作用下，我这个找工作的苦逼也有机会看到今年的华科保研的c语言上机题目。完全是无聊时间多了没事干闲的不行才写了几行代码。</p>

<h3>第一题</h3>

<ul>
<li>某加密算法对数据字节进行加密，具体算法为：<br/>
1.对字节的8位二进制位从右向左0~7编号，先将0、2、4位分别于1、3、5位两两对应交换<br/>
2.然后对0~5位进行循环左移（左边移出的位接到右边），循环左移的位数由6、7两位所组成的二进制数的值决定
编写程序，输入一行明文字符串，按上述算法进行加密后输出密文。<br/>
例如，输入：<code>abcd↙</code>，则输出：<code>dbfp↙</code></li>
</ul>


<!-- more -->


<p>看到题目后一眼就看出是要考<code>&gt;&gt;</code>、<code>&lt;&lt;</code>、<code>&amp;</code>、<code>|</code>什么的，不算是太难吧。我的代码如下：</p>

<div><script src='https://gist.github.com/3803322.js?file='></script>
<noscript><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define c1(c) ((((c) &lt;&lt; 1) &amp; 0x2a) | (((c) &gt;&gt; 1) &amp; 0x15))   // 交换
#define c2(c) ((c) &gt;&gt; 6)  // 循环左移位数
#define c3(c) ((c1((c)) &gt;&gt; 6 - c2((c))) | ((c1((c)) &lt;&lt; c2((c))) &amp; 0x3f) | ((c) &amp; 0xc0)) //循环

void encode(char *s);

int main(void)
{
    char instr[200];
    puts(&quot;input a string:&quot;);
    gets(instr);
    encode(instr);
    puts(instr);
    return 0;
}

void encode(char *s)
{
    int i = 0;
    while(s[i] != '\0')
        s[i++] = (c3(s[i]));
}</code></pre></noscript></div>


<h3>第二题</h3>

<ul>
<li>八张扑克牌叠放在桌面上，从上到下牌面一次为2、3、4、5、6、7、8、9。输入三个整数，每读入一个整数n，先按n进行切牌，然后洗牌，接着读入下一个整数n，如此进行3轮切牌和洗牌。每轮切牌和洗牌后，按从上到下次序输出八张扑克牌的牌面。<br/>
<strong>切牌规则</strong>：<br/>
1.若整数<code>n&gt;0</code>且<code>n&lt;8</code>，则将排从上向下数第n张牌下面的所有牌移到整堆排的最上面；<br/>
2.否则，不移动任何牌。<br/>
<strong>切牌规则</strong>：<br/>
1.从上向下数，将第5~8四张牌按顺序插入到1~4张排下面。</li>
</ul>


<p>例如，输入：<code>2 3 4↙</code>，则输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>round 1: 48596273
</span><span class='line'>round 2: 93642875
</span><span class='line'>round 3: 29837654</span></code></pre></td></tr></table></div></figure>


<p>题目好长，叙述也好乱，看了好几分钟才理清楚切牌洗牌什么的。如果硬要找一下这个题的考点，我猜是数组吧……用字符数组可以很方便地“切牌”，我的代码如下：</p>

<div><script src='https://gist.github.com/3803759.js?file='></script>
<noscript><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void cut(char *poker, int n);   // 切牌
void shuffle(char *poker);      // 洗牌

int main(void)
{
    char poker[9] = &quot;23456789&quot;;
    int n[3] = {0, 0, 0};
    int i = 0;

    scanf(&quot;%d %d %d&quot;, n, n+1, n+2);

    while(i &lt; 3)
    {
        cut(poker, *(n+i));
        shuffle(poker);
        printf(&quot;round 1: %s\n&quot;, poker);
        ++i;
    }

    return 0;
}

void cut(char *poker, int n)
{
    char temp[9];
    if(n&lt;1 || n&gt;7)
        return;
    strcpy(temp, poker);
    temp[n] = 0;
    strcpy(poker, poker + n);
    strcat(poker, temp);
}

void shuffle(char *poker)
{
    char temp[9] = &quot;xxxxxxxx&quot;;
    int i = 0;
    while(i &lt; 4)
    {
        temp[2*i] = poker[i];
        temp[2*i + 1] = poker[i+4];
        ++i;
    }
    strcpy(poker, temp);
}
</code></pre></noscript></div>


<h3>第三题</h3>

<ul>
<li>编写一个程序，按给定的条件，对所输入的每行表达式进行求值，然后输出结果。假设有如下声明语句：
<code>int a = 1, b = 2, c = 3, d = 4, e = 5;</code>
待求值的表达式通过键盘输入，每行输入一个表达式，长度小于20个字符，输入一个空行来结束处理。<br/>
所输入的表达式应满足c语言语法规定，其中包括：变量名a~e，十进制整型常量，圆括号，及双目运算符<br/>
1.算数运算符：<code>*</code>、<code>/</code>、<code>%</code>、<code>+</code>、<code>-</code><br/>
2.位运算符：<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&amp;</code>、<code>^</code>、<code>|</code><br/>
3.简单赋值运算符：<code>=</code><br/>
除上述成分外，表达式中不含其他字符。运算符的功能以及<strong>优先级</strong>和<strong>结合性</strong>遵循<strong>c标准</strong>。</li>
</ul>


<p>看到这个题第一反应时编译原理，但细细一想，上机时间也就2个小时，要实现一个简单解释器时间还是挺紧的。仔细看了题目，发现题目给出的条件都很严格。例如，输入的式子是正确的，因此不必检查式子的正确性，只需按优先级结合性把结果算出来就行了。<br/>
我最先的想法是先不考虑括号，用一个数组A来存放a、b、c、d、e这几个变量的值，用一个字符串s存放整个算式。先找出整个算式中优先级最高的运算符，然后把这个运算符左右两边的变量或整数取出，记作子串sub，把sub的结果计算出来，转成字符串，再替换sub串之前在s中的位置。如果该运算符是<code>=</code>，则更新数组的值，将新的值转成字符串。这样一直循环处理字符串，直到式子中没有运算符或变量为止。<br/>
如果考虑括号，则遇到括号时，对括号中的子串进行上述处理，得到一个不能再被计算的结果字符串，然后用这个结果字符串替换之前子串的位置，再进行一下上面的分析。<br/>
计算过程可以用递归的方式实现，代码在200行左右。<br/>
我的代码如下，支持赋值运算的版本还有点bug，我就不贴出来了。拍砖的轻点……</p>

<div><script src='https://gist.github.com/3803883.js?file='></script>
<noscript><pre><code>// 这个版本不支持赋值运算

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void preproccess(char *buf, int a, int b, int c, int d, int e);
void replace(char *buf, int start, int end, int number);
void mult_analytic(char *buf);
void remove_bracket(char *buf);
void analytic(char *buf, char *op);
int  calculate(char *buf, int n);

void preproccess(char *buf, int a, int b, int c, int d, int e)
{
    int i = 0;
    while(buf[i] != 0)
    {
        if(buf[i] == ' ')
            strcpy(buf+i, buf+i+1);
        else if(buf[i] == '&gt;' &amp;&amp; buf[i+1] == '&gt;')
            strcpy(buf+i, buf+i+1);
        else if(buf[i] == '&lt;' &amp;&amp; buf[i+1] == '&lt;')
            strcpy(buf+i, buf+i+1);
        else
            i++;
    }
}

void replace(char *buf, int start, int end, int number)
{
    char t_buf_1[20];
    char t_buf_2[20];
    int i = 0;

    itoa(number, t_buf_1, 10);
    strcpy(t_buf_2, buf+end+1);
    strcpy(buf+start, t_buf_1);
    strcat(buf+start+strlen(t_buf_1), t_buf_2);
}

void mult_analytic(char *buf)
{
    char op[6][3] = {
        {'*', '/', '%'},
        {'+', '-', '-'},
        {'&lt;', '&gt;', '&gt;'},
        {'&amp;', '&amp;', '&amp;'},
        {'^', '^', '^'},
        {'|', '|', '|'}
    };
    int i = 0;

    remove_bracket(buf);
    while(i &lt; 6)
    {
        analytic(buf, op[i++]);
    }
}

void remove_bracket(char *buf)
{
    int i = 0;
    int j = 0;
    int k = 0;
    char t_buf[20];

    while(buf[i] != 0)
    {
        if(buf[i] == '(')
            ++j;
        else if(buf[i] == ')')
            ++k;
        i++;
    }

    if(j != k)  // 判断括号配对
        return;
    else if(j == 0)     // 判断有无括号
        return;

    j = k = -1;
    i = 0;
    while(buf[i] != 0)  // 寻找最内层括号
    {
        if(buf[i] == '(')
            j = i;
        else if(buf[i] == ')')
        {
            k = i;
            break;
        }
        i++;
    }

    if(k != -1 &amp;&amp; j == -1)
        return;

    // 分析括号里面的式子，存入t_buf
    strcpy(t_buf, buf + j + 1);
    t_buf[k-j-1] = '\0';

    mult_analytic(t_buf);   // 分析并计算式子

    replace(buf, j, k, atoi(t_buf));

    remove_bracket(buf);
}

void analytic(char *buf, char* op)
{
    int i = 0;
    int j = 0;
    int k = 0;

    if(buf[i] == '-' &amp;&amp; isdigit(buf[i+1]))
        i++;
    while(buf[i] != 0)
    {
        if(buf[i] == op[0] || buf[i] == op[1] || buf[i] == op[2])
        {
            break;
        }
        i++;
    }
    if(i &gt;= strlen(buf))
        return;

    j = k = i;
    while(isdigit(buf[j-1]))
        --j;
    if(j == 1 &amp;&amp; buf[0] == '-' &amp;&amp; isdigit(buf[1]))
        --j;
    if(buf[k+1] == '-' &amp;&amp; isdigit(buf[k+2]))
        ++k;
    while(isdigit(buf[k+1]))
        ++k;
    replace(buf, j, k, calculate(buf + j, k-j+1));
    analytic(buf, op);
}

int calculate(char *buf, int n)
{
    char t_buf_1[20];
    char t_buf_2[20];
    char op;
    int a = 0;
    int b = 0;
    int i = 0;

    if(buf[i] == '-' &amp;&amp; isdigit(buf[i+1]))
        i++;
    while(isdigit(buf[i]))
        i++;
    if(i &gt;= strlen(buf))
        return atoi(buf);
    strncpy(t_buf_1, buf, i);
    t_buf_1[i] = 0;
    op = buf[i];
    strncpy(t_buf_2, buf + i + 1, n-i-1);
    t_buf_2[n-i-1] = '\0';
    a = atoi(t_buf_1);
    b = atoi(t_buf_2);
    switch(op)
    {
        case '*':   return (a*b);
        case '/':   return (a/b);
        case '%':   return (a%b);
        case '+':   return (a+b);
        case '-':   return (a-b);
        case '&lt;':    return (a&lt;&lt;b);
        case '&gt;':    return (a&gt;&gt;b);
        case '^':   return (a^b);
        case '&amp;':   return (a&amp;b);
        case '|':   return (a|b);
        default: return 0;
    }
    return 0;
}

int main(void)
{
    int a, b, c, d, e;
    char buf[60];

    puts(&quot;input a b c d e&quot;);
    scanf(&quot;%d %d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e);
    fflush(stdin);
    puts(&quot;input a expression&quot;);
    gets(buf);

    preproccess(buf, a, b, c, d, e);
    mult_analytic(buf);

    printf(&quot;= %d\n&quot;, atoi(buf));

    system(&quot;pause&quot;);
    return 0;
}
</code></pre></noscript></div>


<p>上面的方法比较好理解，但是效率不高。后来在<a href="http://dingstyle.me">天下无双、史上最牛逼的丁大神</a>的提醒下又想到了其他的一些方法。<br/>
构造一个栈，然后将输入的中缀表达式转换成<strong>逆波兰表达式</strong>，逆波兰式就很容易编程求解了。<br/>
或者用这个表达式构造一棵<strong>二叉树</strong>。对这棵树进行化简即可的倒结果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress个人博客搭建笔记]]></title>
    <link href="http://lovep.me/blog/2012/08/19/build-blog/"/>
    <updated>2012-08-19T09:35:00+08:00</updated>
    <id>http://lovep.me/blog/2012/08/19/build-blog</id>
    <content type="html"><![CDATA[<p>正如官网上所说的那样——“A blogging framework for hackers”，Octopress绝对是折腾控、装逼控搭建博客最<strike>不</strike>二的选择。<br/>
Octopress的可定制性非常高，所有的显示效果都可以自己设定，也有很多主题可以下载。默认主题非常简洁，这是我选择的原因之一。</p>

<h3>step 1 - 准备工作</h3>

<ul>
<li>首先注册一个<a href="http://www.github.com">GitHub</a>帐号。将要搭建的博客内容都是托管在GitHub上的。假设你注册了名为<code>username</code>的ID；</li>
<li>然后本地配置Github。在Windows下最简单的方式就是安装一个“GitHub for Windows”，这是最不折腾的方式。这里有一个<a href="http://rogerdudler.github.com/git-guide/index.zh.html">GitHub入门</a>；</li>
<li>接下来安装<a href="http://rubyinstaller.org/">Ruby</a>。注意下载的版本是1.92；</li>
<li>安装<a href="http://115.156.191.66/download/372297/384990/4/exe/136/168/1344846989448_680/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe">DevKit</a>。注意解压安装的路径不能有空格。</li>
<li>添加UTF-8相关的环境变量。在环境变量中添加<code>LANG</code>和<code>LC_ALL</code>两个变量，参数都设置为<code>zh_cn.UTF-8</code>，<strong>注意大小写</strong>。</li>
</ul>


<!-- more -->


<h3>step 2 - 生成博客模版</h3>

<p>现在GitHub上创建一个项目(Repository)，命名为<code>username.github.com</code><br/>
* 打开Shell，用下面命令把GitHub上的Octopress项目克隆到本地</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git username.github.com</span></code></pre></td></tr></table></div></figure>


<p>此时你的计算机上应该有一个名为<code>username.github.com</code>的文件夹，接下来要修改这个文件夹里面的内容<br/>
* 把<code>.rvmrc</code>里面的文件内容修改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rvm use 1.9.2</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改<code>Gemfile</code>里的Source地址如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source "http://ruby.taobao.org"</span></code></pre></td></tr></table></div></figure>


<p>原来的链接据说因为<a href="http://zh.wikipedia.org/wiki/GFW">GFW</a>的原因不能用了，你懂的</p>

<ul>
<li>然后运行如下命令，安装相应的Gem：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bundle update</span></code></pre></td></tr></table></div></figure>


<ul>
<li>接下来生成博客模版：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>这一步的搭建工作完成</p>

<h3>step 3 - 分发到GitHub上</h3>

<p>运行下面命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>接下来会提示你输入Repository URL，URL格式如：<code>git@github.com:username/username.github.com.git</code>，具体内容因你的username和GitHub上的Repository名字而定，GitHub上能找到地址。</p>

<h3>step 4 - 配置你的个人博客</h3>

<p>打开默认目录下面的<code>_config.yml</code>文件，文件有很详细的注释。修改里面的内容，把数据改成你自己的，下面就是我自己的部分配置</p>

<div><script src='https://gist.github.com/3391394.js?file='></script>
<noscript><pre><code># ----------------------- #
#      Main Configs       #
# ----------------------- #

url: http://lovep.me
title: &quot;#{GZShi}的个人博客&quot;
subtitle: 书犹药也，善读之可以医愚
author: GuozhongShi
simple_search: http://google.com/search
description:

# Default date format is &quot;ordinal&quot; (resulting in &quot;July 22nd 2007&quot;)
# You can customize the format as defined in
# http://www.ruby-doc.org/core-1.9.2/Time.html#method-i-strftime
# Additionally, %o will give you the ordinal representation of the day
date_format: &quot;ordinal&quot;

# RSS / Email (optional) subscription links (change if using something like Feedburner)
subscribe_rss: /atom.xml
subscribe_email:
# RSS feeds can list your email address if you like
email:

# ----------------------- #
#    Jekyll &amp; Plugins     #
# ----------------------- #

# If publishing to a subdirectory as in http://site.com/project set 'root: /project'
root: /
permalink: /blog/:year/:month/:day/:title/
source: source
destination: public
plugins: plugins
code_dir: downloads/code
category_dir: blog/categories
markdown: rdiscount
pygments: false # default python pygments have been replaced by pygments.rb

paginate: 10          # Posts per page on the blog index
pagination_dir: blog  # Directory base for pagination URLs eg. /blog/page/2/
recent_posts: 5       # Posts in the sidebar Recent Posts section
excerpt_link: &quot;阅读全文 &amp;rarr;&quot;  # &quot;Continue reading&quot; link text at the bottom of excerpted articles

titlecase: true       # Converts page and post titles to titlecase

# list each of the sidebar modules you want to include, in the order you want them to appear.
# To add custom asides, create files in /source/_includes/custom/asides/ and add them to the list like 'custom/asides/custom_aside_name.html'
default_asides: [asides/recent_posts.html, asides/weibo.html, asides/github.html, asides/twitter.html, asides/googleplus.html]
</code></pre></noscript></div>


<p>必须要强调的是，每个项目如果有值，<strong>冒号后面必须先跟一个空格</strong>，据说这是<code>YAML</code>的语法规定。<br/>
更多个性化的配置可以参考<a href="http://zonyitoo.github.com/blog/2012/04/14/octopresszhu-ti-ji.markdown/">这里</a>、<a href="http://chen.yanping.me/cn/blog/2012/01/07/theming-and-customization/">这里</a>以及<a href="http://octopress.org/docs/">这里</a>~</p>

<h3>step 5 - 写你的第一篇博客</h3>

<ul>
<li>创建文章的命令：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post['my-first-article']</span></code></pre></td></tr></table></div></figure>


<p>然后进入<code>source/_posts</code>目录下，你会发先多了一个<code>.markdown</code>文件。随便用一个文本编辑器打开它，写下你的第一篇博客。<br/>
这个.markdown文件要遵循Markdown的语法，如果出现语法错误的话，很可能导致你的博客不能成功生成。<br/>
* 保存后用下面的命令编译你的博客：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<ul>
<li>接下来预览：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>此时在你的浏览器里面输入<code>localhost:4000</code>即可查看你的博客。<br/>
在预览状态下你可一对.markdown文件进行实时修改，修改完毕保存后直接刷新网页就能看到新的效果。<code>_config.yml</code>的某些修改也是可以直接刷新呈现的。<br/>
预览效果满意的话接下来就可以同步到GitHub上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>如果没出什么问题的话就可以访问<code>username.github.com</code>访问你的博客了~</p>

<h3>step 6 - 备份你的博客数据</h3>

<p><code>source/_post</code>里面保存了你所有的博客内容，这是你最重要的数据。现在要新建一个Repository分支备份保存你的文章，具体操作如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd source/_post/
</span><span class='line'>git init
</span><span class='line'>git add *
</span><span class='line'>git commit -m '1st commit'
</span><span class='line'>git remote add origin git@github.com:username/username.github.com.git</span></code></pre></td></tr></table></div></figure>


<p>接下来创建并切换到名为<code>backup</code>的分支：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git checkout -b backup</span></code></pre></td></tr></table></div></figure>


<p>然后运行下面命令把文章备份到GitHub上</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add *
</span><span class='line'>git commit -m 'my backup'
</span><span class='line'>git push origin backup</span></code></pre></td></tr></table></div></figure>


<h3>结束</h3>

<p>没用过Wordpress，没有比较的资格，不过Octopress确实很好用:-)</p>

<h3>本文参考</h3>

<ol>
<li><a href="http://hivan.me/octopress-install-to-windows8/">Windows 8安装Octopress记录</a>;</li>
<li><a href="http://www.yangzhiping.com/tech/octopress.html">Ruby开源项目介绍(1)：octopress——像黑客一样写博客</a>;</li>
<li><a href="http://mrzhang.me/blog/blog-equals-github-plus-octopress.html">Blog = GitHub + Octopress</a>.</li>
</ol>


<h3>如果因为你的文章里面插入了代码而无法生成博客，请参考</h3>

<ol>
<li><a href="http://netwjx.github.com/blog/2012/04/21/using-code-in-octopress/">在Octopress中使用代码高亮</a>;</li>
<li><a href="http://linyi.herokuapp.com/blog/fix-syntax-highlighting.html">修复octopress中代码无法高亮</a>;</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Octopress添加新浪微博侧边栏]]></title>
    <link href="http://lovep.me/blog/2012/08/18/hello-world/"/>
    <updated>2012-08-18T15:35:00+08:00</updated>
    <id>http://lovep.me/blog/2012/08/18/hello-world</id>
    <content type="html"><![CDATA[<h3>Step 1 - 获取微博秀代码</h3>

<p>进入新浪微博的帐号设置里选择微博小工具中的微博秀，设置完成后赋值下面的嵌入代码</p>

<p>代码大致如下：</p>

<div><script src='https://gist.github.com/3385130.js?file='></script>
<noscript><pre><code>&lt;iframe width=&quot;100%&quot; height=&quot;550&quot; class=&quot;share_self&quot;  frameborder=&quot;0&quot; scrolling=&quot;no&quot; 
src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=550&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=1&amp;isWeibo=1&amp;isFans=1&amp;uid=OOOOOOOOOO&amp;verifier=XXXXXXX&amp;dpc=1&quot;&gt;&lt;/iframe&gt;</code></pre></noscript></div>


<p>只需要记住这部分代码中的uid和verifier即可</p>

<!--more-->


<h3>Step 2 - 创建侧边栏网页</h3>

<p>随便新建一个html文件，将下面的html代码拷进去，然后保存</p>

<div><script src='https://gist.github.com/3385105.js?file='></script>
<noscript><pre><code>{% if site.weibo_uid %}
&lt;section&gt;
    &lt;h1&gt;Sina Weibo&lt;/h1&gt;
    &lt;ul id=&quot;weibo&quot;
    &lt;li&gt;
        &lt;iframe
        width=&quot;100%&quot;
        height=&quot;550&quot;
        class=&quot;share_self&quot;
        frameborder=&quot;0&quot;
        scrolling=&quot;no&quot;
        src=&quot;http://widget.weibo.com/weiboshow/index.php?width=0&amp;height=550&amp;ptype={% if site.weibo_pic %}1{% else %}0{% endif %}&amp;speed=0&amp;skin={{weibo_skin}}&amp;isTitle=0&amp;noborder=1&amp;isWeibo={% if site.weibo_show %}1{% else %}0{% endif %}&amp;isFans={{weibo_fansline}}&amp;uid={{site.weibo_uid}}&amp;verifier={{site.weibo_verifier}}&quot;&gt;
        &lt;/iframe&gt;
    &lt;/li&gt;
    &lt;/ul&gt;
&lt;/section&gt;
{% endif %}</code></pre></noscript></div>


<p>保存的路径为source/_include/asides/</p>

<p>侧边栏的宽度是自适应的，高度为550px，这些可以直接修改上面的参数</p>

<h3>Step 3 - 修改‘_config.yml’文件</h3>

<p>修改示例如下：</p>

<div><script src='https://gist.github.com/3385132.js?file='></script>
<noscript><pre><code># list each of the sidebar modules you want to include, in the order you want them to appear.
# To add custom asides, create files in /source/_includes/custom/asides/ and add them to the list like 'custom/asides/custom_aside_name.html'
default_asides: [asides/recent_posts.html, asides/weibo.html, asides/github.html, asides/twitter.html, asides/googleplus.html]

# Each layout uses the default asides, but they can have their own asides instead. Simply uncomment the lines below
# and add an array with the asides you want to use.
# blog_index_asides:
# post_asides:
# page_asides:

# ----------------------- #
#   3rd Party Settings    #
# ----------------------- #

#Sina Weibo
weibo_uid: 21444XXXXX
weibo_verifier: d13OOOOO
weibo_fansline: 1
weibo_show: true
weibo_pic: false
weibo_skin: 2</code></pre></noscript></div>


<p>weibo_uid和weibo_verifier都是第一步获取的</p>

<p>接下来就编译你的Octopress看看效果吧</p>
]]></content>
  </entry>
  
</feed>
