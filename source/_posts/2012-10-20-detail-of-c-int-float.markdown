---
layout: post
title: "0不等于0"
date: 2012-10-20 00:43
comments: true
categories: 
---
如果两个浮点数表示0，那么这两个浮点数的大小是否一样呢？也许你会马上想到用下面这个程序来验证你的想法  
``` c
int main(void)
{
	float f1 = 0.0;
	float f2 = 0.0;
	if(f1 == f2)
		puts("equal!");
	return 0;
}
```
毫无疑问，这个程序的显示结果必然是`equal!`。  
<!-- more -->
那么尝试一下运行下面的程序
``` c
#include <stdio.h>

int main(void)
{
	int a = 0x80000000;
	int b = 0x8000ffff;
	float *f1 = (float *)&a;
	float *f2 = (float *)&b;

	if(*f1 != *f2)
		printf("%f != %f\n", *f1, *f2);

	return 0;
}
```
运行后你会发现显示的结果是`-0.000000 != -0.000000`，这个结果有点违反直觉，为什么呢？这还得从计算机如何表示浮点数说起。  
c语言是按照[`IEEE 754`](http://zh.wikipedia.org/wiki/IEEE_754)的标准表示浮点数的。所有能表示的浮点数可以分为三类：`规格化的值`、`非规格化的值`和`特殊值`。

规格化的值表示阶码不全为1或全为0的数。非规格化的值表示阶码全为0的数，这种数的其中一个用途是提供了0的表示方式，因为在规格化的数中尾数总是包含一个1的，这样不可能表示0，当阶码全为0时无论尾数如何，表示的都是0.0或-0.0。特殊值是阶码全为1的数，表示一个无穷大，根据符号位决定是正无穷或负无穷，这不是一个数。

回到刚才的程序，f1和f2指向的都是一个非规格化的数，因此字面上的值都是0.0，但为什么比较起来会不一样呢？

其实IEEE 754的设计是非常妙的，阶码的值是采用特殊移码表示而且偏置值是-127而不是-128，这样提供了一个从非规格化的值向规格花的值平滑过渡的表示方法。如果把浮点数在内存中的表达方式用整型解释的话，得到的数和浮点表示的时候的大小顺序是一致的，如此的话在比较两个浮点数大小的时候就能直接采用处理整型数的方法去处理浮点数，这样能降低浮点数处理的复杂度。

这样就不难解释为什么上面的程序的结果为什么会如此了。

###参考引用
1. 《深入理解计算机系统》，Randal E. Bryant  David R. O'Hallaron 著，龚奕利 雷迎春 译。